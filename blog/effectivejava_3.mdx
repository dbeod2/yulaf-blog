---
title: "이펙티브자바 3장 모든 객체의 공통 메서드"
date: "2024-10-20"
slug: "effective-java-3"
---
이번 장은 Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 모두 재정의를 염두에 두고 설계된 것이라고한다. 그래서 재정의 시 언제 어떻게 재정의해야 하는지 다룬다.

또한, 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어 있는데 그 규칙을 확실히 지켜가며 재정의 해야한다는 것이다.

# item 10. equals는 일반 규약을 지켜 재정의하라

꼭 필요한 경우가 아니라면 equals를 재정의하지 말자라고 되어있지만 equals를 재정의해야 할 때가 있을 것이다. 그런 상황에서 일반 규약을 명확하게 지켜서 재정의 하라는 것이다. 

이제 일반 규약을 알아보도록 해야겠다. 

우선, **equals를 재정의**해야 할 때는 언제일까? 

**논리적 동치(동등)성**을 비교해야 하는 경우다.
자바에서 기본적으로 제공하는 equals() **메서드**는 메모리 주소를 비교하는 방식이므로, 두 객체의 **내용이나 상태가 동일한지**를 판단하려면 이 메서드를 재정의해야한다.
 

```java
public class Person {

    private String name;
    private int age;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }
//**두 사람의 이름과 나이가 같다면 두 객체는 논리적으로 동일하다고 판단한다.**
}

```

eqauls메서드를 재정의할 때는 반드시 규약을 따라야한다고 한다. 

다음은 Object명세에 적힌 규약이다. 

eqauls메서드는 동치관계를 구현하며, 다음을 만족한다. 

- 반사성(reflexivity) : 객체는 자기 자신과 항상 동일해야합니다.
    - null이 아닌 모든 참조값x에대해, x. equals(x)는true다.
- 대칭성(symmetry) :  두 객체가 서로 동일하다고 판단되면, 그 반대의 경우도 동일해야 한다
    - null이 아닌 모든 참조값x, y에대해, x. equals(y)가true면 y.equals(x)도true다.
    
    ```java
    // 대칭성 위배되는 코드이다. 
    
    @Override 
    public boolean equals (Object o) {
    	if (o instanceof CaseInsensitiveString) 
    		return s.equalsIgnoreCase (((CaseInsensitiveString) o).s);
    	if (oinstanceofString) // 한 방향으로 흐르기때문에 문제가된다.
    		return .s equalsignoreCase ((String) o); return false;
    }
    
    public static void main(String[] agrs){
    	CaseInsensitiveString cis = new CaseInsensitiveString("hello");
    	String s = "HELLO";
    	
    	// cis.equals(s)는 true
    	System.out.println(cis.equals(s));  // true
    	
    	// 그러나, s.equals(cis)는 false (대칭성 위반)
    	System.out.println(s.equals(cis));  // false
    }
    ```
    
- 추이성(transitivity) : null이 아닌 모든 참조값x,y,z에 대해 x.equals(y)가 tru이고 y.equals(z)도 true이면 x.equals(z)도 true이다.
- 일관성(consistency) : 두 객체의 비교 결과는 그 객체들의 상태가 변경되지 않는 한 항상 동일해야한다.
    - null이 아닌 모든 참조값 x,y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
- null-아님 : null-아님은 이름 처럼 모든 객체가 null과 같지 않아야 한다는 뜻이다.
    - null이 아닌 모든 참조값 x에 대해 x.equals(null)은 false다.

여기까지 일반 규약이고, 이 내용을 종합해서 equals 메서드 제대로 구현 방법을 단계별로 정리해본다.

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다. 
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다. 
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대응되는 `핵심` 필드들이 모두 일치하는지 하나씩 검사한다. 

위 일반 규약으로 작성한 예시이다.

```java
// 코드 10-6 전형적인 equals 메서드의 예 (64쪽)
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;

    public PhoneNumber(int areaCode, int prefix, int lineNum) {
        this.areaCode = rangeCheck(areaCode, 999, "지역코드");
        this.prefix   = rangeCheck(prefix,   999, "프리픽스");
        this.lineNum  = rangeCheck(lineNum, 9999, "가입자 번호");
    }

    private static short rangeCheck(int val, int max, String arg) {
        if (val < 0 || val > max)
            throw new IllegalArgumentException(arg + ": " + val);
        return (short) val;
    }

    @Override public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof PhoneNumber))
            return false;
        PhoneNumber pn = (PhoneNumber)o;
        return pn.lineNum == lineNum && pn.prefix == prefix
                && pn.areaCode == areaCode;
    }

    // 나머지 코드는 생략 - hashCode 메서드는 꼭 필요하다(아이템 11)!
}
```

마지막으로 주의사항이다. 

- equals를 재정의할 땐 hashCode도 반드시 재정의하자
- 너무 복잡하게 해결하려 들지말자
    - 필드들의 동치성만 검사해도 equals규약을 쉽게 지킬 수 있다.
    - 일반적으로 alias는 비교하지 않는게 좋다
- object외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자

# item 11. equals를 재정의하려거든 hashCode도 재정의하라

상황에 따라 equlas를 재정의 하는데 그럴 때 hashCode도 재정의해야 한다. 

그렇지 않으면 hashCode일반 규약을 어기게 되어 문제가 발생할 수 있다고한다. 

그렇다면 hashCode 일반 규약을 알아보자

- equlas 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode메서드는 몇 번 호출해도 일관되게 항상 같은 값을 반환해야한다.
- equlas가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
- equlas가 두 객체를 다라다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시 테이블의 성능이 좋아진다.

이런 규약들이 있고, **hashCode 재정의를 잘못했을 때 크게 문제가 되는 조항은 두번째**이다. 
즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야한다.  
그러나 hashCode는 물리적으로 같은 메모리에 위치한 객체만 동일한 값이 나오기 때문에, 규약과 달리 서로 다른 값을 반환하게 된다. 

이 때문에 잘못된 hashcode를 가진 phoneNumber객체는 다음과 같은 상황에서 오류가 발생할 수 있다.

```java
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5309), "Jenny");
m.get(new PhoneNumber(707, 867, 5309)) // "Jenny"가 아닌 null이 나온다.
```
그러면 똑같은 해시코드를 반환하면 되지 않을까? 

```java
@Override 
public int hashCode() {
	return 42;
}
```

이 방법은 안된다고한다. 항상 같은 hashCode는 모든 객체가 해시테이블의 버킷 하나에 담겨 마치 연결리스트 처럼동작하고 객체가 늘어날수록 성능 저하를 일으킨다고 한다.

그럼 올바른 해쉬 코드를 만드는 방법은 무엇일까? 

```java
@Override
public int hashCode() {
  int result = Integer.hashCode(areaCode);
	result = 31 * result + Integer.hashCode(areaCode);
	result = 31 * result + Integer.hashCode(areaCode);
	return result;
}
```

이 방법은 핵심 필드 3개만 사용해 간단한 계산만 수행한다. 비결정적 요소는 전혀 없으므로 동치인 phoneNumber 인스턴스들은 같은 해시코드를 가질 것이 확실하다고 한다.

주의할 점 

- equals에 논리적 동치를 확인하는데 사용하지 않는 필드는 빼고 해야한다.
- 만약 hash로 바꾸려는 필드가 기본 타입이 아닌 해당 필드의 hashCode를 불러 구현한다.
- 참조 타입 필드가 null일 경우 0을 사용한다.
- 31을 곱하는 이유는 비슷한 필드가 여러개일 때 해시효과를 크게 높여주기 위해서이다.

왜 31 일까..?

- 짝수이고 오버플로가 발생하면 정보를 잃게된다.
- 책에는 소수여서 31이라고한다.. ? 정확한 이유는 아직 모르겠다
- 연산을 빠르게 처리할 수있다. 31 * i는 jvm 최적화해 `(i<<5)` - i 로 바꿔 쉬프트 연산을 하도록 설계되어있다.

- 해쉬 충돌이 더 적은 방법을 꼭 써야한다면 구아바의 hashing을 참고하라고 한다.
- Object클래스에 hash함수도 있지만 성능이 느리다.
```java
@Override
public int hashCode() {
  return Objects.hash(lineNum,prefix,areaCode);
}
```

클래스가 불변이고 해시코드를 계산하는 비용이 크다면 매번 새로 계산하기 보다는 캐싱을 고려해야한다. 

객체가 주로 해시의 키로 사용될 것 같다면 인스턴스가 만들어질 때 해시코드를 계산해줘야한다. 

또한, 해시의 키로 사용되지 않는 경우라면 hashCode가 처음 불릴 때 꼐산하는 지연 초기화 전략을 고려해봐도 좋다. 

```java
private int hashCode;

@Override
public int hashCode() {
	int result = hashCode;
  if(result == 0) {
	  int result = Integer.hashCode(areaCode);
	  result = 31 * result + Integer.hashCode(areaCode);
	  result = 31 * result + Integer.hashCode(areaCode);
	  hashCode = result;
	}
    return result;
}
```

지연초기화 상황은 스레드 안정성을 고려해야 한다. 

성능을 높인다고 해시코드를 계산할 때 핵심필드를 생략해선 안된다.

속도야 빨라지겠지만, 해시 품질이 나빠진다고한다. 

# item12. toString을 항상 재정의하라

Object의 기본 toString메서드가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다. toString을 잘 구현한 클래스는 사용하기에 훨씬 좋고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다. 이러한 이유때문에 toString을 항상 재정의 하라는 말이다.