---
title: "Transaction 정리"
date: "2024-04-20"
slug: "transaction"
---

**데이터베이스에서 수행되는 여러작업을 하나의 논리적 단위로 수행하는 것!**

### 트랜잭션의 연산

**COMMIT** : 트랜잭션 내에서 수행된 모든 변경 사항을 영구적으로 데이터베이스에 반영하는 작업이며, 트랜잭션이 성공적으로 완료되었을 때, COMMIT 명령을 실행함으로써 데이터베이스는 트랜잭션이 변경한 모든 데이터에 대한 수정 사항을 확정하게 된다.

**ROLLBACK** : 트랜잭션이 실패하거나 문제가 발생하는 경우, 트랜잭션 동안 수행된 모든 변경 사항을 무효화하고, 데이터베이스를 트랜잭션 시작 전 상태로 되돌리는 작업이다.

### 트랜잭션 특징

**ACID 속성(Atomicity, Consistency, Isolation, Durability),**

**트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질** 

A (원자성) : all or noting : 특정 트랜잭션이 연산이 모두 수행되거나 수행되지 말아야한다.

C (일관성) : 데이터 무결성 제약 조건을 맞춘다.

 I  (고립성) : 어떤 트랜잭션이 연산 수행시 다른 트랜잭션에 영향을 주거나 받아도 안된다.

- 같은 데이터 수정시 순차적으로 처리해야 고립성을 만족한다. (성능상 단점이 된다)

D (지속성) : 성공적으로 수행되면 영구적으로 반영되어야한다.

### 트랜잭션 동작 원리

쿼리가 실행이 되면 쿼리 처리기를 통해서 쿼리가 통과된다.

쿼리를 처리하기 위해서 데이터캐시로 가서 관련 데이터를 찾는데 없다면 데이터 파일에가서 관련 데이터를 수집해 온다 

그리고 데이터 캐시에 쌓아준다. 

그 후 바로 쿼리를 처리하는게 아니라 로그 캐시로 가서 로그를 먼저 기록한다. 

변경 전/ 후 기록을 하게된다. 

### 트랜잭션 롤백 과정

트랜잭션 실패가 감지되면, **Undo Log**에 기록된 내용을 바탕으로 변경된 데이터를 역순으로 되돌리는 작업이 시작된다.

1. 트랜잭션이 실패하기 전의 상태로 되돌려 모든 변경 사항을 무효화한다.
    1. 데이터 롤백은 undo로그를 통해서 역순으로 기록을 하면 기존 상태로 원복이 된다. 
2. 이 과정에서 데이터는 트랜잭션이 시작되기 전 상태로 완벽하게 복원된다.

### 고립수준

**트랜잭션 고립 수준이 필요한 이유는 동시성 문제로 인한 데이터 불일치나 충돌을 방지하여 데이터의 일관성과 무결성을 보장하기 위해서이다.**

여기서 **동시성 문제 유형**을 알아야한다. 

**Dirty Read**: 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 현상.

**Non-repeatable Read**: 같은 데이터를 여러 번 읽을 때 다른 트랜잭션에 의해 데이터가 변경되어 결과가 달라지는 현상.

**Phantom Read**: 트랜잭션이 범위 조회를 여러 번 수행할 때, 그 사이에 다른 트랜잭션에 의해 데이터가 삽입되거나 삭제되어 결과가 달라지는 현상.

**Isolation Levels**

**read uncommitted**

- 아직 커밋되지 않은 데이터를 읽을 수 있다. 트랜잭션의 격리성이 거의 보장되지 않는다.
- 동시성 문제가 해결이 되지 않는다.

**read committed**

- 커밋된 데이터만 읽을 수 있다. 상용 데이터베이스에서 기본으로 사용하며, 커밋되지 않은 데이터를 읽지 않으므로 **Dirty Read** 문제를 방지한다.
- non-repeatable read, Phantom read 문제는 허용된다.

**repeatable-read** 

- 한 트랜잭션 내에서 같은 데이터를 반복 조회시 같은 값을 반환한다. 따라서 Non-repeatable read 문제를 방지한다.
- phantom read 문제는 허용된다.

**serializable** 

- 가장 높은 고립수준이며, 속도가 느리다는 단점이 있지만, 트랜잭션이 순차적으로 실행된다. 트랜잭션간의 상호 간섭이 완전 차단되며, 모둔 동시성 문제를 방지한다.

고립수준을 통해 동시성 문제를 어느 정도 허용할지 설정이 필요하다. 무조건 높은 수준의 고립을 설정한다고 해결되는 문제가 아니기 때문에 데이터베이스 성능이나 요구사항에 따라 적절하게 선택해야 한다.